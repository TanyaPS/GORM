#!/usr/bin/perl
#
# ftpuploader - FTP/SFTP uploader
#
# ftpuploader forks a FTP/SFTP client per destination.
# Each destination process monitor a local directory on this host. For each new file, the process
# uploads the file to destination as configured.
#
# Soren Juul Moller, Nov 2019

use strict;
use warnings;
use Getopt::Std;
use Net::FTP;
use Net::SFTP::Foreign;
use Linux::Inotify2;
use Utils;
use Logger;

my $PLATFORM = 'gpsftp5';	# Set to gpsftp4 if running on gpsftp4
my $Privatekey = (defined $ENV{'HOME'} ? $ENV{'HOME'}:'/root') . '/.ssh/gnss-uploader';	# only used by gpsftp4

my $Debug = 0;	# set with -d option

###################################################
# ftpuploader sub process
#
sub ftpuploader($) {
  my $conf = shift;
  my ($name, $host, $protocol, $user, $pass, $privatekey, $localdir, $remotedir) =
     map { defined $conf->{$_} ? $conf->{$_}:"" } qw(name host protocol user pass privatekey localdir remotedir);
  undef $conf;

  chdir($localdir) || errdie("$0: chdir: $!\n");
  select(STDERR); $| = 1;                # Unbuffered output
  select(STDOUT); $| = 1;                # Unbuffered output

  sysrun("mkdir failed") unless -d "failed";

  # Arm directory monitor
  my $inotify = new Linux::Inotify2;
  my $watch = $inotify->watch($localdir, IN_CLOSE_WRITE | IN_MOVED_TO);

  loginfo("$name uploader started");

  my $ftp;		# Net::FTP or Net::SFTP::Foreign object
  my %todo = ();	# $todo{$filename} = $retrycount
  my $first = 1;

  my $sig = '';
  local $SIG{'TERM'} = sub { $sig = 'SIGTERM' };
  local $SIG{'INT'}  = sub { $sig = 'SIGKILL' };
  local $SIG{'ALRM'} = 'IGNORE';

  Inbound:
  while (!$sig) {
    my @files = dirlist($localdir);
    foreach my $fn (@files) {
      next if -d $fn;
      $todo{$fn} = 0 unless defined $todo{$fn};
    }

    if (scalar(keys %todo) == 0) {
      my $v = '';
      vec($v, $inotify->fileno, 1) = 1;
      select($v, undef, undef, 300);			# wait 300s for inotify has something
      last if $sig;
      if (vec($v, $inotify->fileno, 1)) {
        my @in_events = $inotify->read;			# Inotify has something. Read it all
        foreach my $e (@in_events) {			# and put it in %todo.
          my $fn = $e->name;
          next if $fn eq "failed";
          next unless -f $fn;
          $todo{$fn} = 0 unless defined $todo{$fn};
        }
      }
    }

    if (scalar(keys %todo) == 0) {
      if (defined $ftp) {
        # stop session while waiting for files
        $ftp->quit() if $protocol eq 'ftp';
        undef $ftp;
      }
      next;
    }

    # Do the uploads
    @files = sort { substr($a,4,4) cmp substr($b,4,4) } keys %todo;
    foreach my $fn (@files) {
      next unless -f $fn;

      if ($todo{$fn} > 3) {
        logerror("Giving up on $fn after $todo{$fn} tries. Moved to $localdir/failed");
        unlink("$localdir/failed/$fn");
        rename("$localdir/$fn", "$localdir/failed/$fn");
        delete $todo{$fn};
        next;
      }
      $todo{$fn}++;	# Increase try count

      my $rc = 0;

      if (!defined $ftp) {
        # start a new session
        if ($protocol eq 'ftp') {
          $ftp = Net::FTP->new($host, Passive => 1);
          $rc = $ftp->login($user, $pass);
          if (!$rc) {
            logerror("Cannot login at $host with user $user: ".$ftp->message);
            undef $ftp;
            next Inbound;
          }
          $ftp->binary();
        }
        elsif ($protocol eq 'sftp') {
          loginfo("Login as $user using privatekey $privatekey") if $Debug;
          $ftp = Net::SFTP::Foreign->new($host, user => $user, key_path => $privatekey);
          if ($ftp->error) {
            logerror("Cannot login at $host with user $user: ".$ftp->error);
            undef $ftp;
            next Inbound;
          }
        }
        else {
          logerror("Unknown protocol: $protocol. Exiting...");
          exit(1);
        }
      }

      # Contruct destination path
      # Replace all %words with values
      my $destpath = $remotedir;
      if (index($remotedir, '%') >= 0) {
        my ($site, $site4, $year, $doy, $hour, $hh);
        # TEJH00DNK_R_20171890000_01D_30S_MO.rnx
        if ($fn =~ /^([a-zA-Z0-9]{9})_R_([0-9]{4})([0-9]{3})([0-9]{2})/) {
          ($site, $year, $doy, $hh) = ($1, $2, $3, $4);
          $site4 = substr($site, 0, 4);
          $hour = chr(ord('a')+$hh);
        }
        # HABY333a.19d.Z
	elsif ($fn =~ /^([a-z0-9]{4})([0-9]{3})([a-x0])\.([0-9]{2})[dng]/i) {
	  ($site4, $doy, $hour, $year) = ($1, $2, $3, sy2year($4));
          $hh = ($hour eq '0') ? 24 : ord(lc($hour))-97;
          $site = $site4.($site4 eq 'ARGI' ? '00FRO':'00DNK');
        }
	$destpath =~ s/%site/$site/g;
	$destpath =~ s/%site4/$site4/g;
	$destpath =~ s/%year/$year/g;
	$destpath =~ s/%doy/$doy/g;
	$destpath =~ s/%hour/$hour/g;
	$destpath =~ s/%hh24/$hh/g;
        if ($destpath =~ /%/) {
          logerror("Invalid variable in $destpath");
          unlink("$localdir/failed/$fn");
          rename("$localdir/$fn", "$localdir/failed/$fn");
          delete $todo{$fn};
          next;
        } 
      }

      # Create remotedir if it does not exist
      # Assume remotedir exists if not dynamic
      if (index($remotedir, '%') >= 0) {
        if ($protocol eq 'ftp') {
          $rc = $ftp->cwd($destpath);
          $ftp->mkdir($destpath, 1) if !$rc;
        }
        elsif ($protocol eq 'sftp') {
          $rc = $ftp->setcwd($destpath);
          $ftp->mkpath($destpath, undef, 0) if $ftp->error;
        }
      }

      # Try upload
      $destpath .= '/' unless $destpath =~ /\/$/;
      loginfo("$localdir/$fn -> $protocol://$host$destpath$fn");
      $rc = $ftp->put($fn, $destpath.$fn);
      if ($protocol eq 'sftp' && $ftp->error) {
        logerror("Error SFTP uploading $fn: ".$ftp->error);
      } elsif ($protocol eq 'ftp' && !$rc) {
        logerror("Error FTP uploading $fn: ".$ftp->message);
      } else {
        unlink("$localdir/$fn");
        delete $todo{$fn};
      }
    }
  }

  loginfo("ftpuploader [$name] stopped.".($sig ? " signal=$sig":""));
}

###################################################
# Spawn new/created clients not already started
# and kill deleted/deactived running clients
#
my %PIDS;
my %TS;
use GPSDB;

sub reload() {
  my $DB = new GPSDB;
  my $confs;
  if ($PLATFORM eq 'gpsftp4') {
    # backward compat
    $confs = $DB->DBH->selectall_arrayref(q{
	select	f.name, f.host, f.user, f.pass, p.path localdir, f.remotedir
	from	ftpupload f, paths p
	where	f.localdir = p.name
	  and	f.active = 1
    }, { Slice => {} });
    # add fields not present on gpsftp4
    foreach my $conf (@$confs) {
      $conf->{'ts'} = 'none';				# timestamp not supported by gpsftp4
      if ($conf->{'name'} =~ /^sftp-/) {		# If rulename starts with sftp-, then protocol is sftp
        $conf->{'protocol'} = 'sftp';
        $conf->{'privatekey'} = $Privatekey;		# gpsftp4 supports only one common key for all dests
      } else {
        $conf->{'protocol'} = 'ftp';
      }
    }
  } else {
    $confs = $DB->DBH->selectall_arrayref(q{
	select	f.name, f.host, f.protocol, f.user, f.pass, f.privatekey, p.path localdir, f.remotedir, f.ts
	from	uploaddest f, localdirs p
	where	f.localdir = p.name
	  and	f.active = 1
    }, { Slice => {} });
  }
  $DB->{'DBH'}->disconnect;
  undef $DB;	# we don't want this cloned to the childs.

  my $changed = 0;

  # Stop all not in config
  foreach my $name (keys %PIDS) {
    my $found = 0;
    foreach my $conf (@$confs) {
      $found = 1 if $conf->{'name'} eq $name && $conf->{'ts'} eq $TS{$name};
    }
    next if $found;
    loginfo("Stopping ftpuploader [$name]");
    kill(15, $PIDS{$name});
    delete $PIDS{$name};
    delete $TS{$name};
    $changed = 1;
  }

  # Start all in config not already running
  foreach my $conf (@$confs) {
    my $name = $conf->{'name'};
    next if exists $PIDS{$name} && kill(0, $PIDS{$name});
    if ($conf->{'protocol'} eq 'ftp' && (!exists $conf->{'pass'} || $conf->{'pass'} eq "")) {
      logerror("$name: ftp user without password ignored");
    }
    else {
      # Spawn child
      my $pid = fork();
      die("$0: cannot fork") unless defined $pid;
      if ($pid == 0) {
        # Child
        $0 = "ftpuploader [$name]";
        ftpuploader($conf);
        exit(0);
      }
      # Parent
      $PIDS{$name} = $pid;
      $TS{$name} = $conf->{'ts'};
      $changed = 1;
    }
  }
  loginfo("config (re)loaded") if $changed;
}

#
# Main program
#
my %opts = ();
getopts('v:d:l:k:', \%opts);
$Debug = $opts{'v'} if defined $opts{'v'};

# Backward compat
my $pidfile;
if ($PLATFORM eq 'gpsftp4') {
  my $errlog = (defined $opts{'l'} ? $opts{'l'} : '/dev/null');
  daemonize($errlog) if defined $opts{'d'};
  $pidfile = (defined $opts{'p'} ? $opts{'p'} : '/var/run/ftpuploader.pid');
  create_pid_file($pidfile);
}

$Privatekey = $opts{'k'} if defined $opts{'k'};

setprogram("ftpuploader");
$0 = "ftpuploader [master]";

reload();
loginfo("ftpuploader [master] started (".(scalar(keys %PIDS))." instances)");

while (1) {
  eval {
    local $SIG{INT} = sub { loginfo("interrupted"); die("interrupted"); };
    local $SIG{TERM} = sub { loginfo("terminated"); die("terminated"); };
    local $SIG{HUP} = sub { die("SIGHUP") };
    local $SIG{CHLD} = 'IGNORE';
    sleep(300);  # check for config change every 5min or if HUP'ed
  };
  last if $@ && $@ !~ /^SIGHUP/;	# exit on anything but SIGHUP
  reload();
}

kill(15, $_) foreach values %PIDS;	# Kill all childs
wait;
unlink($pidfile) if defined $pidfile;

loginfo("ftpuploader [master] stopped");
exit(0);
