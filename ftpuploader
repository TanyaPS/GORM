#!/usr/bin/perl
#
# ftpuploader - FTP/SFTP uploader.
#
# ftpuploader forks a FTP/SFTP client per destination.
# Each destination process monitor a local directory on this host. For each new file, the process
# uploads the file to destination as configured.
#
# Soren Juul Moller, Nov 2019

use strict;
use warnings;
use Getopt::Std;
use Net::FTP;
use Net::SFTP::Foreign;
use Linux::Inotify2;
use lib '/home/gpsuser';
use BaseConfig;
use Utils;
use Logger;
use GPSDB;

###################################################
# ftpuploader sub process
#
sub ftpuploader($) {
  my $conf = shift;
  my ($name, $host, $protocol, $user, $pass, $privatekey, $localdir, $remotedir) =
     map { defined $conf->{$_} ? $conf->{$_}:"" } qw(name host protocol user pass privatekey localdir remotedir);
  undef $conf;

  chdir($localdir) || errdie("$0: chdir: $!\n");
  select(STDERR); $| = 1;                # Unbuffered output
  select(STDOUT); $| = 1;                # Unbuffered output

  system("mkdir failed") unless -d "failed";

  # Setup signal handling
  my $sig_received = 0;
  local $SIG{TERM} = sub { $sig_received = 1; };
  local $SIG{INT}  = sub { $sig_received = 1; };
  local $SIG{HUP}  = 'IGNORE';

  # Arm directory monitor
  my $inotify = new Linux::Inotify2;
  my $watch = $inotify->watch($localdir, IN_CLOSE_WRITE | IN_MOVED_TO);

  loginfo("$name uploader started");

  my $ftp;		# Net::FTP or Net::SFTP::Foreign object
  my %todo = ();	# $todo{$filename} = $retrycount
  my $first = 1;

  Inbound:
  while (!$sig_received) {
    my @files = dirlist($localdir);
    foreach my $fn (@files) {
      next if -d $fn;
      $todo{$fn} = 0 unless defined $todo{$fn};
    }

    if (scalar(keys %todo) == 0) {
      my @in_events = ();
      eval {
        local $SIG{ALRM} = sub { die("alarm\n") };
        alarm 301;
        @in_events = $inotify->read;
        alarm 0;
      };
      if ($@) {
        last unless $@ eq "alarm\n";        # Alarm?
      }
      foreach my $e (@in_events) {
        my $fn = $e->name;
        next if $fn eq "failed";
        $todo{$fn} = 0 unless defined $todo{$fn};
      }
    }

    if (scalar(keys %todo) == 0) {
      if (defined $ftp) {
        # stop session while waiting for files
        $ftp->quit() if $protocol eq 'ftp';
        undef $ftp;
      }
      next;
    }

    # do the uploads
    @files = sort { substr($a,4,4) cmp substr($b,4,4) } keys %todo;
    foreach my $fn (@files) {
      last if $sig_received;
      next unless -f $fn;

      if ($todo{$fn} > 3) {
        logerror("Giving up on $fn after $todo{$fn} tries. Moved to $localdir/failed");
        unlink("$localdir/failed/$fn");
        rename("$localdir/$fn", "$localdir/failed/$fn");
        delete $todo{$fn};
        next;
      }
      $todo{$fn}++;

      my $rc = 0;

      # start a new session not logged in
      if (!defined $ftp) {
        if ($protocol eq 'ftp') {
          $ftp = Net::FTP->new($host, Passive => 1, Debug => 1);
          $rc = $ftp->login($user, $pass);
          if (!$rc) {
            logerror("Cannot login at $host with user $user: $rc.");
            undef $ftp;
            next Inbound;
          }
          $ftp->binary();
        }
        elsif ($protocol eq 'sftp') {
          loginfo("Login as $user using privatekey $privatekey");
          $ftp = Net::SFTP::Foreign->new($host, user => $user, key_path => $privatekey);
          if ($ftp->error) {
            logerror("Cannot login at $host with user $user: ".$ftp->error);
            undef $ftp;
            next Inbound;
          }
        }
        else {
          logerror("Unknown protocol: $protocol. Exiting...");
          exit(1);
        }
      }

      # Contruct destination path
      my $destpath = $remotedir;
      if ($destpath =~ /%/) {
        #TEJH00DNK_R_20171890000_01D_30S_MO.rnx
        my ($site, $year, $doy);
        if ($fn =~ /^([a-zA-Z0-9]{4}).{5}_R_([0-9]{4})([0-9]{3})/) {
          ($site, $year, $doy) = ($1, $2, $3);
        }
        $destpath =~ s/%site%/$site/g if defined $site;
        $destpath =~ s/%year%/$year/g if defined $year;
        $destpath =~ s/%doy%/$doy/g if defined $doy;
        if ($destpath =~ /%/) {
          logerror("File $fn not recognized or invalid variable");
          unlink("$localdir/failed/$fn");
          rename("$localdir/$fn", "$localdir/failed/$fn");
          delete $todo{$fn};
          next;
        } 
      }

      # Change dir to $destpath. Create if necessary.
      if ($protocol eq 'ftp') {
        $rc = $ftp->cwd($destpath);
        if (!$rc) {
          $ftp->mkdir($destpath, 1);
          $rc = $ftp->cwd($destpath);
        }
      }
      elsif ($protocol eq 'sftp') {
        $rc = $ftp->setcwd($destpath);
        if ($ftp->error) {
          $ftp->mkpath($destpath, undef, 0);
          $rc = $ftp->setcwd($destpath);
        }
      }
      if (!$rc) {
        logerror("Cannot change dir to $destpath");
        next;
      }

      # Try upload
      $destpath .= '/' unless $destpath =~ /\/$/;
      loginfo("upload $fn -> $destpath$fn");
      $rc = $ftp->put($fn, $fn);
      if ($protocol eq 'sftp' && $ftp->error) {
        logerror("Error SFTP uploading $fn: ".$ftp->error);
      } elsif ($protocol eq 'ftp' && !$rc) {
        logerror("Error FTP uploading $fn");
      } else {
        unlink("$localdir/$fn");
        delete $todo{$fn};
      }
    }
  }

  loginfo("ftpuploader [$name] stopped");
}

###################################################
# Spawn new/created clients not already started
# and kill deleted/deactived running clients
#
my %PIDS;
my %TS;
sub reload() {
  my $DB = new GPSDB;
  my $confs = $DB->DBH->selectall_arrayref(q{
	select	f.name, f.host, f.protocol, f.user, f.pass, f.privatekey, p.path localdir, f.remotedir, f.ts
	from	uploaddest f, localdirs p
	where	f.localdir = p.name
	  and	f.active = 1
  }, { Slice => {} });
  undef $DB;

  my $changed = 0;

  # Stop all not in config
  running:
  foreach my $name (keys %PIDS) {
    foreach my $conf (@$confs) {
      next running if $conf->{'name'} eq $name && $conf->{'ts'} eq $TS{$name};
      loginfo("Stopping ftpuploader [$name]");
    }
    next unless exists $PIDS{$name};
    kill(15, $PIDS{$name});
    delete $PIDS{$name};
    delete $TS{$name};
    $changed = 1;
  }

  # Start all in config not already running
  foreach my $conf (@$confs) {
    next if exists $PIDS{$conf->{'name'}};
    if ($conf->{'protocol'} eq 'ftp' && (!exists $conf->{'pass'} || $conf->{'pass'} eq "")) {
      logerror("ftp user without password ignored");
    }
    else {
      my $pid = fork();
      die("$0: cannot fork\n") unless defined $pid;
      if ($pid == 0) {
        # Child
        $0 = "ftpuploader [$conf->{name}]";
        ftpuploader($conf);
        exit(0);
      }
      # Parent
      $PIDS{$conf->{'name'}} = $pid;
      $TS{$conf->{'name'}} = $conf->{'ts'};
      $changed = 1;
    }
  }
  loginfo("config loaded") if $changed;
}

#
# Main program
#
my %opts = ();
getopts('dl:p:', \%opts);

my $errlog = (defined $opts{'l'} ? $opts{'l'} : "/dev/null");
daemonize($errlog) if defined $opts{'d'};
setprogram("ftpuploader");
my $pidfile = (defined $opts{'p'} ? $opts{'p'} : $FTPUPLOAD_PID);
create_pid_file($pidfile);

# Setup signal handling
my $sig_received = 0;
local $SIG{TERM} = sub { loginfo("SIGTERM"); $sig_received = 1; };
local $SIG{INT} = sub { loginfo("SIGINT");   $sig_received = 1; };
local $SIG{HUP} = sub { loginfo("SIGHUP"); };
local $SIG{CHLD} = 'IGNORE';	# We dont care about return codes from childs

loginfo("ftpuploader [master] started (".(scalar(keys %PIDS))." instances)");

while (!$sig_received && -f $pidfile) {
  reload();
  sleep(1800);  # check for config change every half hour or if HUP'ed
}

kill(15, $_) foreach values %PIDS;	# Kill all childs
wait;
unlink($pidfile);

loginfo("ftpuploader [master] stopped");
exit(0);
