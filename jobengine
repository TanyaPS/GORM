#!/usr/bin/perl
#
# Simple job scheduler.
# Monitor $JOBQUEUE for new job files. Each jobfile spawns a process that runs
# Job->process(). The scheduler defaults to 4 concurrent processes.
#
# Soren Juul Moller, Nov 2019

use strict;
use warnings;
use Getopt::Std;
use Parallel::ForkManager;
use Linux::Inotify2;
use BaseConfig;
use Utils;
use StatusDB;
use Logger;
use RinexSet;
use Job;

my %Pending;
my %Running;
my $Debug = 1;  	# set with -d option
my $FM;			# FormManager


#####################################
# Submit a dayjob on an incomplete day
#
sub force_completion($$$) {
  my ($site, $year, $doy) = @_;

  loginfo("Force completion of $site-$year-$doy");
  my $dayjob = new Job(site => $site, year => $year, doy => $doy);
  my $workdir = $dayjob->getWorkdir;

  my $statusdb = StatusDB->new("$workdir/status.json");

  # Find interval
  my $interval;
  foreach my $hour (keys %$statusdb) {
    next unless $statusdb->{$hour} eq 'processed';
    my $rs = new RinexSet(rsfile => "$workdir/rs.$hour.json");
    $interval = $rs->{'interval'};
    last if defined $interval;
  }

  # Submit dayjob
  if (defined $interval) {
    ($dayjob->{'hour'}, $dayjob->{'interval'}, $dayjob->{'incomplete'}) = ('0', $interval, 1);
    $dayjob->submitjob('hour2daily');
    $statusdb->{'0'} = 'queued';
  } else {
    logerror("Cannot force completion of $site-$year-$doy. No proccessed hours.");
  }
  $statusdb->save();
}


#####################################
# Look for forced incomplete days and submit them
#
sub scan_for_forced_incompletes() {
  sub dirscan($) {
    my $dir = shift;
    opendir(my $dh, $dir);
    my @dirs = grep { index($_,'.') != 0 && -d "$dir/$_" } readdir($dh);
    closedir($dh);
    return @dirs;
  }
  foreach my $site (dirscan($WORKDIR)) {
    foreach my $year (dirscan("$WORKDIR/$site")) {
      foreach my $doy (dirscan("$WORKDIR/$site/$year")) {
        my $w = "$WORKDIR/$site/$year/$doy";
        next unless -f "$w/force-complete" && -f "$w/status.json";
        unlink("$w/force-complete");
        force_completion($site, $year, $doy);
      }
    }
  }
}


#####################################
# Run command issued by someone like admin.cgi
#
sub runcommand($) {
  my $file = shift;
  open(my $fd, '<', $file);
  my $cmd = <$fd>; chomp;
  close($fd);

  if ($cmd =~ /^reload ftpuploader/) {
    sysrun("systemctl reload ftpuploader");
  }
  elsif ($cmd =~ /^force complete (\w+) (\d+) (\d+)/) {
    force_completion($1, $2, $3);
  }
}


#####################################
# Spawn a job using ForkManager
#
sub runjob($) {
  my $jobfile = shift;

  return unless -f $jobfile;

  # If filename ends with 'command', then assume it is a command file
  if ($jobfile =~ /command$/) {
    # message from admin.cgi
    runcommand($jobfile);
    unlink($jobfile);
    return;
  }

  # otherwise assume it's a JSON file
  my $job = new Job(jobfile => $jobfile);
  unlink($jobfile);

  unless (defined $job && $job->verifyobj()) {
    logerror("invalid jobfile $jobfile");
    return;
  }

  # Duplicate event check
  my $ident = $job->getIdent;
  if (exists $Running{$ident}) {
    logerror("Duplicate job $ident");
    return;
  }

  my $workdir = $job->getWorkdir;
  my $statusdb = StatusDB->new("$workdir/status.json");
  my $status = $statusdb->{$job->{'hour'}};
  $status = "" unless defined $status;
  if ($status eq "running") {
    $statusdb->unlock();
    logerror("Duplicate job $ident");
    return;
  } else {
    $statusdb->{$job->{'hour'}} = 'running';
    $statusdb->save();
  }
  undef $statusdb;   # unlcok before spawn

  loginfo("Run $ident");
  $Running{$ident} = $job;		# need this in onfinish()
  $FM->start($ident) && return;  	# start instance
  setprogram("job");
  chdir($workdir);
  eval {
    $job->process();
    return 1;
  } || do {
    logerror("FATAL ERROR: $@");	# Serious program error occurred.
  };
  $FM->finish(0);			# exit this instance
}


##########################################
# Callback called when a child finishes
# Might be delayed since it called upon process being reaped.
#
sub onfinish() {
  my ($pid, $exitcode, $ident) = @_;
  delete $Running{$ident};
}


#####################################
# Inotify2 callback
# Called for each new file arrived in queue
#
sub inotify_callback() {
  my $event = shift;
  alarm 0;
  runjob($event->fullname);
}


########################################################################################################
# Main program
#
my %opts = ();
getopts('c:di:l:', \%opts);

BaseConfig::init($opts{'c'}) if defined $opts{'c'};

my $log = (defined $opts{'l'} ? $opts{'l'} : "/dev/null");
$Debug = 1 if defined $opts{'d'};

my $Ninstances = (defined $opts{'i'} ? $opts{'i'} : $JOBINSTANCES);

setprogram($0);
$0 = basename($0)." ".join(' ',@ARGV);

select(STDERR); $| = 1;         # Unbuffered output
select(STDOUT); $| = 1;         # Unbuffered output

# Initialize ForkManager
$FM = new Parallel::ForkManager($Ninstances);
$FM->run_on_finish(\&onfinish);

loginfo("jobengine started with $Ninstances instances");

# Run jobs in queue already
runjob("$JOBQUEUE/$_") foreach dirlist($JOBQUEUE);

# Setup queue event handler
my $inotify = new Linux::Inotify2;
my $watcher = $inotify->watch($JOBQUEUE, IN_MOVED_TO | IN_CLOSE_WRITE, \&inotify_callback);

# Need a fast poll interval to reap finished childs quickly
# But we do not need to scan files that frequently
my $lastscan = time();
my $scaninterval = 300;		# Scan for force-complete every 5 min

# main loop
while (1) {
  eval {
    local $SIG{ALRM} = sub { die("jobenginealarm") };
    local $SIG{INT} = sub { die("interrupted") };
    local $SIG{TERM} = sub { die("terminated") };
    local $SIG{HUP} = sub { die("SIGHUP") };
    alarm 15;		# Use a short timeout to allow fast reaping
    $inotify->poll;	# wait for new file in $INCOMING
    alarm 0;
  };
  if ($@) {
    my $msg = $@;
    if ($msg =~ /^jobenginealarm|^SIGHUP/) {
      # ForkManager needs reaping of finished childs to force callback
      $FM->reap_finished_children;
      next if $FM->running_procs > 0;

      if (time() > $lastscan + $scaninterval) {
        # No jobs in queue or running, check for leftovers.
        runjob("$JOBQUEUE/$_") foreach dirlist($JOBQUEUE);

        # Scan for manually forced incompletes.
        scan_for_forced_incompletes();
        $lastscan = time();
      }
    } elsif ($msg =~ /^(\w+)/) {
      loginfo($1);
      last;
    }
  }
}

$watcher->cancel;
$FM->wait_all_children;
