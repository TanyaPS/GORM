#!/usr/bin/perl
#############################################################################################
# Monitor for new inbound GPS data files from Permanent GNSS Stations.
# When a new file arrived, move it to $SAVEDIR and unpack it to $WORKDIR.
# Files are renamed to RINEXv3 standard naming during unpack.
#
# Soren Juul Moller, Dec 2019

use strict;
use warnings;
use threads;
use Thread::Queue;
use BaseConfig;
use Logger;
use Utils;
use Job;

my $Debug = 1;

my $UQ = Thread::Queue->new;	# Unpack queue
my $PQ = Thread::Queue->new;	# Pending queue

#############################################################################################
#############################################################################################
# Unpack thread(s)

sub unpack_file($) {
  my $jqparm = shift;
  my ($ifn, $site, $obsint) = ($jqparm->{'ifn'}, $jqparm->{'site'}, $jqparm->{'obsint'});
  my $fn = basename($ifn);

  my $fd = parseFilename($fn);		# see Utils.pm
  return unless defined $fd;
  my ($year, $doy, $hour) = ($fd->{'year'}, $fd->{'doy'}, $fd->{'hour'});

  my $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint);
  my $workdir = $job->getWorkdir;
  my $rs;

  if ($fd->{'ftyp'} eq 'septentrio-rnx3') {
    my $ftyp = 'UU';
    $ftyp = $1 if $fn =~ /_(MO|[A-Z]N)\.rnx/;
    my $ufn = $fn; $ufn =~ s/\.gz$//;
    my $wfn = "$workdir/$ufn";
    if ($fn =~ /\.gz$/) {
      $wfn =~ s/\.gz$//;
      loginfo("Gunzip $fn to $workdir");
      sysrun("gzip -dc $ifn >$wfn", { log => $Debug });
    } else {
      loginfo("Copy $fn to $workdir");
      syscp($ifn, $wfn, { log => $Debug });
    }
    $ftyp .= '.'.$obsint;

    # Since this is a multi file set, we will have to wait until we do not think
    # any more files will arrive.
    # Register pending job only if we got the observation file (see submit_pending)
    if ($fn =~ /_MO\.rnx/) {
      $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint);
      my $rsfile = $rs->getRsFile;
      $rs->load() if -f $rsfile;
      $rs->{$ftyp} = $ufn;
      $rs->store();
      $PQ->enqueue({ fn => $fn, rsfile => $rsfile });
    }
    return;
  }

  elsif ($fd->{'ftyp'} eq 'septentrio-raw') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, rawfile => $ifn);
    loginfo("Unpack Septentrio raw file $fn into $workdir");
    chdir($workdir);
    my $countrycode = substr($site, 6, 3);
    sysrun("$SBF2RIN -f $ifn -l -R3 -nONGELHI -O $countrycode >/dev/null", { log => $Debug });
    chdir($INCOMING);
    $rs->checkfiles();
  }

  elsif ($fd->{'ftyp'} eq 'trinzic-zip') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, zipfile => $ifn);
    loginfo("Unzipping $fn to ".$rs->getWorkdir);
    $rs->unzip($ifn, $obsint);
  }

  elsif ($fd->{'ftyp'} eq 'leica-zip') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, zipfile => $ifn);
    loginfo("Unzipping $fn to ".$rs->getWorkdir);
    $rs->unzip($ifn, $obsint);
  }

  if (defined $rs) {
    $rs->store();
    $job->{'rsfile'} = $rs->getRsFile;
    $job->submitjob('ftp');
  }
}

#
# Receive files to unpack from main thread.
# Loop ends when main thread calls $UQ->end()
#
sub unpack_thread() {
  while (my $jqparm = $UQ->dequeue()) {
    eval {
      unpack_file($jqparm);
      return 1;
    } || do {
      logerror("FATAL: $@");
      last;
    }
  }
  threads->detach;
}


#############################################################################################
#############################################################################################
# Pending thread
# Submit pending jobs if no files with same prefix is present in $INCOMING
# A job is pending if this is a multi-file upload and the obs file is received. It will be
# submitted if no new files have arrived the last 20s.
#

my %Pending;

sub submit_pending() {
  my @pending = keys %Pending;
  foreach my $fn (@pending) {
    my $rs = $Pending{$fn};
    if (time() - $rs->{'timestamp'} > 19) {
      # check nothing is being transferred right now
      my $prefix = $rs->getFilenamePrefix();
      next if scalar(grep(/^$prefix/, dirlist($INCOMING))) > 0;
      # no active inbound found, then submit
      delete $rs->{'timestamp'};
      $rs->checkfiles();
      $rs->store();
      my $job = new Job(rs => $rs);
      loginfo("Submitting ".$job->getIdent());
      $job->submitjob('ftp');
      delete $Pending{$fn};
    }
  }
  my $left = scalar(keys %Pending);
  loginfo("Pending left: $left") if $left > 0;
}

#
# Receive pending file sets from unpack_thread
# Loop ends when main threads sends the EXIT command.
#
sub pending_thread() {
  while (1) {
    my $parm = $PQ->dequeue_timed(5);
    if (defined $parm) {
      last if defined $parm->{'command'} && $parm->{'command'} eq 'EXIT';
      my $rs = new RinexSet(rsfile => $parm->{'rsfile'});
      $rs->{'timestamp'} = time();
      $Pending{$parm->{'fn'}} = $rs;
    } else {
      submit_pending();
    }
  }
  threads->detach;
}


#############################################################################################
#############################################################################################
# Main thread
# THe main thread monitors $INCOMING for new files.
# Check if site is know, move it away from $INCOMING, and send message to a unpack_thread
# to do the unpacking into $WORKDIR.
#
# IMPORTANT: All database (DBI) operations MUST be in the main thread. DBI is not thread safe.
#

use Linux::Inotify2;
use GPSDB;
use Getopt::Std;

my %SCS;
my $DB = new GPSDB;

#
# Lookup site in gpssums. Returns true if current year-doy exists, false if not.
#
sub dailysum_exists($$$) {
  my ($site, $year, $doy) = @_;

  my $href = $DB->{'DBH'}->selectrow_hashref(q{
	select count(site) cnt
	from gpssums
	where site = ? and year = ? and doy = ? and hour = '0'
  }, undef, $site, $year, $doy);
  if (defined $href && $href->{'cnt'}) {
    logerror("$site-$year-$doy already processed. Forget DOY $site-$year-$doy first.");
    return 1;
  }
  return 0;
}


#
# Load all sites from locations table into %SCS
#
sub load_sites() {
  # Get the complete list of defined sites from DB
  # We only use the short version of sitename here.
  my $dbh = $DB->{'DBH'};
  my $aref = $dbh->selectall_arrayref(q{
	select	site, freq, obsint
	from	locations
  }, { Slice => {} });
  die("No sites defined!?") if !defined $aref || scalar(@$aref) == 0;
  %SCS = map { uc(substr($_->{'site'},0,4)) => $_ } @$aref;
}


#
# Handle one file in $INCOMING
# Move to $SAVEDIR, create $workdir and send to unpack threads
#
sub handle_inbound($) {
  my $ifn = shift;

  my $fn = basename($ifn);
  my $fd = parseFilename($fn);

  # Make sure we know the site
  my $site4 = substr($fn, 0, 4);
  my $sc = $SCS{$site4};
  if (!defined $fd || !defined $sc) {
    sysmv($ifn, $SAVEDIR.'/stale', { log => $Debug, mkdir => 1 });
    logwarn("No such site: $site4");
    return;
  }
  my $site = $sc->{'site'};
  sysmv($ifn, "$SAVEDIR/$site", { log => $Debug, mkdir => 1 });

  my $job = new Job(site => $site, year => $fd->{'year'}, doy => $fd->{'doy'}, hour => $fd->{'hour'}, interval => $sc->{'obsint'});
  my $workdir = $job->getWorkdir();
  if (! -d $workdir) {
    return if dailysum_exists($site, $fd->{'year'}, $fd->{'doy'});
    $job->mkWorkdir();
  }
  $UQ->enqueue({ ifn => "$SAVEDIR/$site/$fn", site => $sc->{'site'}, obsint => $sc->{'obsint'} });
}


#
# Called from Linux::Inotify2 for each file event
#
sub inotify_callback() {
  my $event = shift;
  alarm 0;		# disable timer while processing
  handle_inbound($event->fullname);
}


#
# scan_incoming will add all plain files in $INCOMING to %Inbound
#
sub scan_incoming() {
  my $fd;
  open($fd, '-|', qq(/bin/find $INCOMING -type f -print));
  while (<$fd>) {
    chomp;
    handle_inbound($_) if fileage($_) > 20;
  }
  close($fd);
}


setprogram(basename($0));
$0 = basename($0)." ".join(' ',@ARGV);

my %opts = ();
getopts('c:di:l:', \%opts);

BaseConfig::init($opts{'c'}) if defined $opts{'c'};

$Debug = 1 if defined $opts{'d'};
logchannel($opts{'l'}) if defined $opts{'l'};

my $Nthreads = (defined $opts{'i'} ? $opts{'i'} : $JOBINSTANCES);

chdir($INCOMING);
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

threads->create('unpack_thread') for (1..$Nthreads);
threads->create('pending_thread');

my $inotify = new Linux::Inotify2
	|| errdie("$0: unable to create new inotify object: $!");
$inotify->watch($INCOMING, IN_MOVED_TO | IN_CLOSE_WRITE, \&inotify_callback);

load_sites();

loginfo("$0 started. threads=$Nthreads, Debug=$Debug");

scan_incoming();

while (1) {
  eval {
    local $SIG{ALRM} = sub { die("gpspickupalarm") };
    local $SIG{INT} = sub { die("interrupted") };
    local $SIG{TERM} = sub { die("terminated") };
    local $SIG{HUP} = sub { die("SIGHUP") };
    alarm 300;
    $inotify->poll;
    alarm 0;
  };
  if ($@) {
    last unless $@ =~ /^gpspickupalarm|^SIGHUP/;
    scan_incoming();
    load_sites();
  }
}

# shutdown threads
$PQ->enqueue({ command => 'EXIT' });
$PQ->end();
$UQ->end();
sleep 1 while threads->list(threads::running);		# wait for threads to terminate

loginfo("$0 stopped");
exit(0);
