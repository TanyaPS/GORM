#!/usr/bin/perl
#############################################################################################
# Monitor for new inbound GPS data files from Permanent GNSS Stations.
# When a new file arrived, move it to $SAVEDIR and unpack it to $WORKDIR.
# Files are renamed to RINEXv3 standard naming during unpack.
#
# Soren Juul Moller, Dec 2019

use strict;
use warnings;
use threads;
use Thread::Queue;
use BaseConfig;
use Logger;
use Utils;
use Job;

my $Debug = 0;

my $UQ = Thread::Queue->new;	# Unpack queue
my $PQ = Thread::Queue->new;	# Pending queue


##########################################################################################
# Extract date and time from a filename
# Returns a hash reference with info or undef if not recognized.
#
sub parseFilename($) {
  my $fn = shift;
  my ($site, $site4, $year, $yy, $doy, $mm, $dd, $hour, $hh, $mi, $ftyp, $period);
  study($fn);

  # Septentrio: sssssssss_R_yyyydddhhmi_##H_##S_MO.rnx
  #             sssssssss_R_yyyydddhhmi_##H_xN.rnx
  if ($fn =~ /^([A-Z0-9]{9})_R_([0-9]{4})([0-9]{3})([0-9]{2})([0-9]{2})_[0-9]{2}(H|D)/i) {
    ($site, $year, $yy, $doy, $hh, $hour, $mi, $period) = (uc($1), int($2), year2sy($2), int($3), int($4), hour2letter($4), int($5), $6);
    $hour = '0' if $period eq 'D';
    $ftyp = 'septentrio-rnx3';
    ($year, $mm, $dd) = Doy_to_Date($year, $doy);
  }

  # Septentrio raw: ssssdddh.yy_
  elsif ($fn =~ /^([A-Z0-9]{4})([0-9]{3})([a-z])\.([0-9]{2})_/i) {
    ($site4, $doy, $hour, $hh, $yy, $year, $mi) = (uc($1), int($2), $3, letter2hour($3), int($4), sy2year($4), 0);
    $ftyp = 'septentrio-raw';
    ($year, $mm, $dd) = Doy_to_Date($year, $doy);
  }

  # Trinzic: ssssyyyymmddhhmiB.zip
  elsif ($fn =~ /^([a-z0-9]{4})([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})B\.zip$/i) {
    ($site4, $year, $yy, $mm, $dd, $hh, $hour, $mi) =
		(uc($1), int($2), year2sy($2), int($3), int($4), int($5), hour2letter($5), int($6));
    $ftyp = 'trinzic-zip';
    $yy = year2sy($year);
    $doy = Day_of_Year($year, $mm, $dd);
  }

  # Leica:   ssssdddh*.yyo.zip
  elsif ($fn =~ /^([a-zA-Z0-9]{4})([0-9]{3})([a-xA-X0]).*\.([0-9]{2})[a-z]\.zip$/i) {
    ($site4, $doy, $hour, $hh, $yy, $year, $mi) = (uc($1), int($2), $3, letter2hour($3), int($4), sy2year($4), 0);
    $ftyp = 'leica-zip';
    ($year, $mm, $dd) = Doy_to_Date($year, $doy);
  }

  return undef if !defined $site && !defined $site4;
  if (!defined $site) {
    $site = $site4."00DNK";
    $site = $site4."00FRO" if $site4 eq 'ARGI';		# special case for ARGI
  }
  $site4 = substr($site, 0, 4) if !defined $site4;

  return { site => $site, site4 => $site4, year => $year, doy => $doy, yy => $yy, mm => $mm, dd => $dd,
           hour => $hour, hh => $hh, mi => $mi, ftyp => $ftyp };
}


#############################################################################################
#############################################################################################
# Unpack thread(s)
# Unpack one file into its workdir. There will be Nthreads number of instances of this function.

sub unpack_file($) {
  my $parm = shift;
  my ($ifn, $site, $obsint) = ($parm->{'ifn'}, $parm->{'site'}, $parm->{'obsint'});
  my $fn = basename($ifn);

  my $fd = parseFilename($fn);
  return unless defined $fd;
  my ($year, $doy, $hour) = ($fd->{'year'}, $fd->{'doy'}, $fd->{'hour'});

  my $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint);
  my $workdir = $job->getWorkdir;
  my $rs;

  if ($fd->{'ftyp'} eq 'septentrio-rnx3') {
    my $ftyp = 'UU';
    $ftyp = $1 if $fn =~ /_(MO|[A-Z]N)\.rnx/;
    my $ufn = $fn; $ufn =~ s/\.gz$//;
    my $wfn = "$workdir/$ufn";
    if ($fn =~ /\.gz$/) {
      $wfn =~ s/\.gz$//;
      loginfo("Gunzip $fn to $workdir");
      sysrun("gzip -dc $ifn >$wfn", { log => $Debug });
    } else {
      loginfo("Copy $fn to $workdir");
      syscp($ifn, $wfn, { log => $Debug });
    }
    $ftyp .= '.'.$obsint;

    # Since this is a multi file set, we will have to wait until we do not think
    # any more files will arrive.
    # Register pending job only if we got the observation file (see submit_pending)
    if ($fn =~ /_MO\.rnx/) {
      $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint);
      my $rsfile = $rs->getRsFile;
      $rs->load() if -f $rsfile;
      $rs->{$ftyp} = $ufn;
      $rs->store();
      $PQ->enqueue({ fn => $fn, rsfile => $rsfile });
    }
    return;
  }

  elsif ($fd->{'ftyp'} eq 'septentrio-raw') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, rawfile => $ifn);
    loginfo("Unpack Septentrio raw file $fn into $workdir");
    my $countrycode = substr($site, 6, 3);
    mkdir("$workdir/sbfunpack.$hour");
    chdir("$workdir/sbfunpack.$hour");
    sysrun("$SBF2RIN -f $ifn -l -R3 -nONGELHI -O $countrycode >$workdir/sbf2rin.$hour.log 2>&1", { log => $Debug });
    system("mv $workdir/sbfunpack.$hour/* $workdir");
    chdir($INCOMING);
    system("rm -r $workdir/sbfunpack.$hour");
    $rs->checkfiles();
  }

  elsif ($fd->{'ftyp'} eq 'trinzic-zip') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, zipfile => $ifn);
    loginfo("Unzipping $fn to $workdir");
    $rs->unzip($ifn, $obsint);
  }

  elsif ($fd->{'ftyp'} eq 'leica-zip') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, zipfile => $ifn);
    loginfo("Unzipping $fn to $workdir");
    $rs->unzip($ifn, $obsint);
  }

  if (defined $rs) {
    $rs->store();
    $job->{'rsfile'} = $rs->getRsFile;
    $job->submitjob('ftp');
  }
}

#
# Receive files to unpack from main thread.
# Loop ends when main thread calls $UQ->end()
#
sub unpack_thread() {
  while (my $parm = $UQ->dequeue()) {
    eval {
      unpack_file($parm);
      return 1;
    } || do {
      logerror("FATAL ERROR: ".longmess($parm->{'site'}.'-'.$parm->{'year'}.'-'.$parm->{'doy'}.'-'.$parm->{'hour'}));
      last;
    }
  }
  threads->detach;
}


#############################################################################################
#############################################################################################
# Pending thread
# Submits pending jobs if no files with same prefix is present in $INCOMING
# A job is pending if it is a multi-file upload and the obs file have been received. It will be
# submitted if no new files has arrived within the last 20s.
#

my %Pending;

sub submit_pending() {
  my @pending = keys %Pending;
  foreach my $fn (@pending) {
    my $rs = $Pending{$fn};
    if (time() - $rs->{'timestamp'} > 19) {
      # check nothing is being transferred right now
      my $prefix = $rs->getFilenamePrefix();
      next if scalar(grep(/^$prefix/, dirlist($INCOMING))) > 0;
      # no active inbound found, then submit
      delete $rs->{'timestamp'};
      $rs->checkfiles();
      $rs->store();
      my $job = new Job(rs => $rs);
      loginfo("Submitting ".$job->getIdent());
      $job->submitjob('ftp');
      delete $Pending{$fn};
    }
  }
  my $left = scalar(keys %Pending);
  loginfo("Pending left: $left") if $left > 0;
}

#
# Receive pending file sets from unpack_thread
# Loop ends when main threads sends the EXIT command.
#
sub pending_thread() {
  while (1) {
    my $parm = $PQ->dequeue_timed(5);
    if (defined $parm) {
      last if defined $parm->{'command'} && $parm->{'command'} eq 'EXIT';
      my $rs = new RinexSet(rsfile => $parm->{'rsfile'});
      $rs->{'timestamp'} = time();
      $Pending{$parm->{'fn'}} = $rs;
    } else {
      submit_pending();
    }
  }
  threads->detach;
}


#############################################################################################
#############################################################################################
# Main thread
# THe main thread monitors $INCOMING for new files.
# Check if site is know, move it away from $INCOMING, and send message to a unpack_thread
# to do the unpacking into $WORKDIR.
#
# IMPORTANT: All database (DBI) operations MUST be in the main thread. DBI is not thread safe.
#

use Linux::Inotify2;
use GPSDB;
use Getopt::Std;

my %SCS;
my $DB;

#
# Lookup site in gpssums. Returns true if current year-doy exists, false if not.
#
sub dailysum_exists($$$) {
  my ($site, $year, $doy) = @_;

  my $href = $DB->{'DBH'}->selectrow_hashref(q{
	select count(site) cnt
	from gpssums
	where site = ? and year = ? and doy = ? and hour = '0'
  }, undef, $site, $year, $doy);
  if (defined $href && $href->{'cnt'}) {
    logerror("$site-$year-$doy already processed. Forget DOY $site-$year-$doy first.");
    return 1;
  }
  return 0;
}


#
# Load all sites from locations table into %SCS
#
sub load_sites() {
  # Get the complete list of defined sites from DB
  # We only use the short version of sitename here.
  my $dbh = $DB->{'DBH'};
  my $aref = $dbh->selectall_arrayref(q{
	select	site, freq, obsint
	from	locations
  }, { Slice => {} });
  die("No sites defined!?") if !defined $aref || scalar(@$aref) == 0;
  %SCS = map { uc(substr($_->{'site'},0,4)) => $_ } @$aref;
}


#
# Handle one file in $INCOMING
# Move to $SAVEDIR, create $workdir and send to unpack threads
#
sub handle_inbound($) {
  my $ifn = shift;

  my $fn = basename($ifn);
  my $fd = parseFilename($fn);
  if (!defined $fd || !defined $fd->{'site4'}) {
    logwarn("$fn not recorgnized. Moved to stale.");
    sysmv($ifn, $SAVEDIR.'/stale', { log => $Debug, mkdir => 1 });
    return;
  }

  # Make sure we know the site
  my $sc = $SCS{$fd->{'site4'}};
  if (!defined $sc) {
    logwarn('No such site: '.$fd->{'site'}.'. Moved to stale.');
    sysmv($ifn, $SAVEDIR.'/stale', { log => $Debug, mkdir => 1 });
    return;
  }

  my $site = $sc->{'site'};
  sysmv($ifn, "$SAVEDIR/$site", { log => $Debug, mkdir => 1 });

  my $job = new Job(site => $site, year => $fd->{'year'}, doy => $fd->{'doy'}, hour => $fd->{'hour'}, interval => $sc->{'obsint'});
  my $workdir = $job->getWorkdir();
  if (! -d $workdir) {
    return if dailysum_exists($site, $fd->{'year'}, $fd->{'doy'});
    $job->mkWorkdir();
  }
  $UQ->enqueue({ ifn => "$SAVEDIR/$site/$fn", site => $sc->{'site'}, obsint => $sc->{'obsint'} });
}


#
# Called from Linux::Inotify2 for each file event
#
sub inotify_callback() {
  my $event = shift;
  alarm 0;		# disable timer while processing
  handle_inbound($event->fullname);
}


#
# scan_incoming will add all plain files in $INCOMING to %Inbound
#
sub scan_incoming() {
  my $fd;
  open($fd, '-|', qq(/bin/find $INCOMING -type f -print));
  while (<$fd>) {
    chomp;
    handle_inbound($_) if fileage($_) > 20;
  }
  close($fd);
}

# Below the actual main

setprogram(basename($0));
$0 = basename($0)." ".join(' ',@ARGV);

my %opts = ();
getopts('c:di:l:', \%opts);

BaseConfig::init($opts{'c'}) if defined $opts{'c'};

$Debug = 1 if defined $opts{'d'};
logchannel($opts{'l'}) if defined $opts{'l'};
my $Nthreads = (defined $opts{'i'} ? $opts{'i'} : $JOBINSTANCES);

chdir($INCOMING);
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

# start threads
threads->create('unpack_thread') for (1..$Nthreads);
threads->create('pending_thread');

my $inotify = new Linux::Inotify2
	|| errdie("$0: unable to create new inotify object: $!");
$inotify->watch($INCOMING, IN_MOVED_TO | IN_CLOSE_WRITE, \&inotify_callback);

$DB = new GPSDB;	# GPSDB must be instantiated after thread creations
load_sites();

loginfo("$0 started. threads=$Nthreads, Debug=$Debug");

scan_incoming();

while (1) {
  eval {
    local $SIG{ALRM} = sub { die("gpspickupalarm") };
    local $SIG{INT} = sub { die("interrupted") };
    local $SIG{TERM} = sub { die("terminated") };
    local $SIG{HUP} = sub { die("SIGHUP") };
    alarm 300;
    $inotify->poll;
    alarm 0;
  };
  if ($@) {
    last unless $@ =~ /^gpspickupalarm|^SIGHUP/;
    scan_incoming();
    load_sites();
  }
}

# shutdown threads
$PQ->enqueue({ command => 'EXIT' });
$PQ->end();
$UQ->end();
sleep 1 while threads->list(threads::running);		# wait for threads to terminate

loginfo("$0 stopped");
logclose();
exit(0);
