#!/usr/bin/perl
#############################################################################################
# Monitor for new inbound GPS data files from Permanent GNSS Stations.
# When a new file arrived, move it to $SAVEDIR and unpack it to $WORKDIR.
# Files are renamed to RINEXv3 standard naming during unpack.
#
# Soren Juul Moller, Dec 2019

use strict;
use warnings;
use threads;
use Thread::Queue;
use BaseConfig;
use Logger;
use Utils;
use Job;

my $Debug = 0;

my $UQ = Thread::Queue->new;	# Unpack queue
my $PQ = Thread::Queue->new;	# Pending queue


##########################################################################################
# Extract date and time from a filename
# Returns a hash reference with info or undef if not recognized.
#
sub parseFilename($) {
  my $fn = shift;
  my ($site, $site4, $year, $yy, $doy, $mm, $dd, $hour, $hh, $mi, $ftyp, $period);
  study($fn);

  # Septentrio: sssssssss_R_yyyydddhhmi_##H_##S_MO.rnx
  #             sssssssss_R_yyyydddhhmi_##H_xN.rnx
  if ($fn =~ /^([A-Z0-9]{9})_R_([0-9]{4})([0-9]{3})([0-9]{2})([0-9]{2})_[0-9]{2}(H|D)/i) {
    ($site, $year, $yy, $doy, $hh, $hour, $mi, $period) = (uc($1), int($2), year2sy($2), int($3), int($4), hour2letter($4), int($5), $6);
    $hour = '0' if $period eq 'D';
    $ftyp = 'septentrio-rnx3';
    ($year, $mm, $dd) = Doy_to_Date($year, $doy);
  }

  # Septentrio raw: ssssdddh.yy_
  elsif ($fn =~ /^([A-Z0-9]{4})([0-9]{3})([a-z])\.([0-9]{2})_/i) {
    ($site4, $doy, $hour, $hh, $yy, $year, $mi) = (uc($1), int($2), $3, letter2hour($3), int($4), sy2year($4), 0);
    $ftyp = 'septentrio-raw';
    ($year, $mm, $dd) = Doy_to_Date($year, $doy);
  }

  # Trinzic: ssssyyyymmddhhmiB.zip
  elsif ($fn =~ /^([a-z0-9]{4})([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})B\.zip$/i) {
    ($site4, $year, $yy, $mm, $dd, $hh, $hour, $mi) =
		(uc($1), int($2), year2sy($2), int($3), int($4), int($5), hour2letter($5), int($6));
    $ftyp = 'trinzic-zip';
    $yy = year2sy($year);
    $doy = Day_of_Year($year, $mm, $dd);
  }

  # Leica:   ssssdddh*.yyo.zip
  elsif ($fn =~ /^([a-zA-Z0-9]{4})([0-9]{3})([a-xA-X0])([0-9]+)?\.([0-9]{2})[a-z]\.zip$/i) {
    ($site4, $doy, $hour, $hh, $yy, $year) = (uc($1), int($2), $3, letter2hour($3), int($5), sy2year($5));
    $mi = (defined $4) ? int($4) : 0;
    $ftyp = 'leica-zip';
    ($year, $mm, $dd) = Doy_to_Date($year, $doy);
  }

  return undef if !defined $site && !defined $site4;
  if (!defined $site) {
    $site = $site4."00DNK";
    $site = $site4."00FRO" if $site4 eq 'ARGI';		# special case for ARGI
  }
  $site4 = substr($site, 0, 4) if !defined $site4;

  return { site => $site, site4 => $site4, year => $year, doy => $doy, yy => $yy, mm => $mm, dd => $dd,
           hour => $hour, hh => $hh, mi => $mi, ftyp => $ftyp };
}


#############################################################################################
#############################################################################################
# Pending thread
# Submits pending jobs if no files with same prefix is present in $INCOMING
# A job is pending if it is a multi-file upload and the obs file have been received. It will be
# submitted if no new files has arrived within the last 20s.
#

my %Pending;

sub submit_pending() {
  my @pending = keys %Pending;
  foreach my $ident (@pending) {
    my $rs = $Pending{$ident};
    if (time() - $rs->{'timestamp'} > 19) {
      # check nothing is being transferred right now
      my $prefix = $rs->getFilenamePrefix();
      next if scalar(grep(/^$prefix/, dirlist($INCOMING))) > 0;
      # no active inbound found, then submit
      writefile($rs->getWorkdir()."/status.".$rs->{'hour'}, 'queued');
      delete $rs->{'timestamp'};
      $rs->checkfiles();
      $rs->store();
      my $job = new Job(rs => $rs);
      loginfo("Submitting ".$job->getIdent());
      $job->submitjob('ftp');
      delete $Pending{$ident};
    }
  }
}

#
# Receive pending file sets from unpack_thread
# Loop ends when main threads sends the EXIT command.
#
sub pending_thread() {
  while (1) {
    submit_pending();
    my $parm = $PQ->dequeue_timed(5);
    if (defined $parm) {
      if (defined $parm->{'command'}) {
        last if $parm->{'command'} eq 'EXIT';		# Shutdown requested
        if ($parm->{'command'} eq 'update-ttl') {	# Update TTL on Pending{ident} if exists
          my $rs = $Pending{$parm->{'ident'}};
          $rs->{'timestamp'} = time() if defined $rs;
        }
      } else {
        my $rs = new RinexSet(rsfile => $parm->{'rsfile'});
        $rs->{'timestamp'} = time();
        $Pending{$parm->{'ident'}} = $rs;
      }
    }
  }
  threads->detach;
}


#############################################################################################
#############################################################################################
# Unpack thread(s)
# Unpack one file into its workdir. There will be Nthreads number of instances of this function.

sub unpack_file($) {
  my $parm = shift;
  my ($ifn, $site, $obsint) = ($parm->{'ifn'}, $parm->{'site'}, $parm->{'obsint'});
  my $fn = basename($ifn);

  my $ff = parseFilename($fn);
  if (!defined $ff) {
    logwarn("Cannot recognize file $fn");
    return;
  }

  my ($year, $doy, $hour) = ($ff->{'year'}, $ff->{'doy'}, $ff->{'hour'});

  my $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint);
  my $workdir = $job->getWorkdir;

  # Aquire exclusive access to this hour while unpacking this file
  my $lock = openlocked("$workdir/status.$hour");
  sysread($lock, my $status, -s "$workdir/status.$hour");
  $status = 'none' if !defined $status || $status eq '';

  # Check if it is a legal state for unpacking
  if ($status !~ /^(none|pending|processed)/) {		# Only allow unpack in none/pending/processd state
    logerror("Duplicate unpack?!");
    close($lock);
    return;
  }
  seek($lock, 0, 0); truncate($lock, 0);

  my $rs;

  # Multi file uploads go to the pending thread

  if ($ff->{'ftyp'} eq 'septentrio-rnx3') {
    my $ftyp = 'UU';
    $ftyp = $1 if $fn =~ /_(MO|[A-Z]N)\.rnx/;
    my $ufn = $fn; $ufn =~ s/\.gz$//;
    my $wfn = "$workdir/$ufn";
    if ($fn =~ /\.gz$/) {
      $wfn =~ s/\.gz$//;
      loginfo("Gunzip $fn to $workdir");
      sysrun("gzip -dc $ifn >$wfn", { log => $Debug });
    } else {
      loginfo("Copy $fn to $workdir");
      syscp($ifn, $wfn, { log => $Debug });
    }
    $ftyp .= '.'.$obsint;

    # Since this is a multi file set, we will have to wait until we do not think
    # any more files will arrive.
    # Register pending job only if we got the observation file (see submit_pending)
    my $ident = $job->getIdent();
    if ($fn =~ /_MO\.rnx/) {
      $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint);
      my $rsfile = $rs->getRsFile;
      $rs->{$ftyp} = $ufn;
      $rs->store();
      $PQ->enqueue({ ident => $ident, rsfile => $rsfile });
    } else {
      $PQ->enqueue({ command => 'update-ttl', ident => $ident });
    }
    syswrite($lock, 'pending');
    close($lock);
    return;
  }

  # Single file uploads. Unpack and submit job directly.

  if ($ff->{'ftyp'} eq 'septentrio-raw') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, rawfile => $ifn);
    loginfo("Unpack Septentrio raw file $fn into $workdir");
    my $countrycode = substr($site, 6, 3);
    mkdir("$workdir/sbfunpack.$hour");
    chdir("$workdir/sbfunpack.$hour");
    sysrun("$SBF2RIN -f $ifn -l -R3 -nOP -s -D -O $countrycode >$workdir/sbf2rin.$hour.log 2>&1", { log => $Debug });
    system("mv $workdir/sbfunpack.$hour/* $workdir");
    chdir($INCOMING);
    system("rm -r $workdir/sbfunpack.$hour");
    $rs->checkfiles();
  }

  elsif ($ff->{'ftyp'} eq 'trinzic-zip') {
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, zipfile => $ifn);
    loginfo("Unzipping $fn to $workdir");
    $rs->unzip($ifn, $obsint);
  }

  elsif ($ff->{'ftyp'} eq 'leica-zip') {
    if ($ff->{'mi'} != 0) {
      # TODO: merge split hour into exiting hour
      logwarn("Split hours not supported yet.");
      return;
    }
    $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $obsint, zipfile => $ifn);
    loginfo("Unzipping $fn to $workdir");
    $rs->unzip($ifn, $obsint);
  }

  if (defined $rs) {
    $rs->store();
    $job->{'rsfile'} = $rs->getRsFile;
    $job->submitjob('ftp');
    syswrite($lock, 'queued');
  } else {
    logerror("Unknown filetype: $ff->{'ftyp'}");
    syswrite($lock, 'none');
  }

  close($lock);
}

#
# Receive files to unpack from main thread.
# Loop ends when main thread calls $UQ->end()
#
sub unpack_thread() {
  while (my $parm = $UQ->dequeue()) {
    eval {
      unpack_file($parm);
      1;
    } || do {
      logerror("FATAL ERROR: ".longmess($parm->{'site'}.'-'.$parm->{'year'}.'-'.$parm->{'doy'}.'-'.$parm->{'hour'}));
    }
  }
  threads->detach;
}


#############################################################################################
#############################################################################################
# Main thread
# THe main thread monitors $INCOMING for new files.
# Check if site is know, move it away from $INCOMING, and send message to a unpack_thread
# to do the unpacking into $WORKDIR.
#
# IMPORTANT: All database (DBI) operations MUST be in the main thread. DBI is not thread safe.
#

use Linux::Inotify2;
use GPSDB;
use Getopt::Std;

my %SCS;
my $DB;

#
# Lookup site in gpssums. Returns true if current year-doy exists, false if not.
#
sub dailysum_exists($$$) {
  my ($site, $year, $doy) = @_;

  my $href = $DB->{'DBH'}->selectrow_hashref(q{
	select count(site) cnt
	from gpssums
	where site = ? and year = ? and doy = ? and hour = '0'
  }, undef, $site, $year, $doy);
  if (defined $href && $href->{'cnt'}) {
    logerror("$site-$year-$doy already processed. Forget DOY $site-$year-$doy first.");
    return 1;
  }
  return 0;
}


#
# Load all sites from locations table into %SCS
#
sub load_sites() {
  # Get the complete list of defined sites from DB
  # We only use the short version of sitename here.
  my $dbh = $DB->{'DBH'};
  my $aref = $dbh->selectall_arrayref(q{
	select	site, freq, obsint
	from	locations
  }, { Slice => {} });
  die("No sites defined!?") if !defined $aref || scalar(@$aref) == 0;
  %SCS = map { uc(substr($_->{'site'},0,4)) => $_ } @$aref;
}


#
# Handle one file in $INCOMING
# Move to $SAVEDIR, create $workdir and send to unpack threads
#
sub handle_inbound($) {
  my $ifn = shift;

  my $fn = basename($ifn);
  my $ff = parseFilename($fn);
  if (!defined $ff || !defined $ff->{'site4'}) {
    logwarn("$fn not recorgnized. Moved to stale.");
    sysmv($ifn, $SAVEDIR.'/stale', { log => $Debug, mkdir => 1 });
    return;
  }

  # Make sure we know the site
  my $sc = $SCS{$ff->{'site4'}};
  if (!defined $sc) {
    logwarn('No such site: '.$ff->{'site'}.'. Moved to stale.');
    sysmv($ifn, $SAVEDIR.'/stale', { log => $Debug, mkdir => 1 });
    return;
  }

  my ($site, $year, $doy) = ($sc->{'site'}, $ff->{'year'}, $ff->{'doy'});
  my $savedir = sprintf("%s/%s/%4d/%03d", $SAVEDIR, $site, $year, $doy);
  sysmv($ifn, $savedir, { log => $Debug, mkdir => 1 });

  my $job = new Job(site => $site, year => $ff->{'year'}, doy => $ff->{'doy'}, hour => $ff->{'hour'}, interval => $sc->{'obsint'});
  my $workdir = $job->getWorkdir();
  if (! -d $workdir) {
    return if dailysum_exists($site, $ff->{'year'}, $ff->{'doy'});
    $job->mkWorkdir();
  }
  $UQ->enqueue({ ifn => "$savedir/$fn", site => $sc->{'site'}, obsint => $sc->{'obsint'} });
}


#
# scan_incoming will add all plain files in $INCOMING to %Inbound
#
sub scan_incoming() {
  my $fd;
  open($fd, '-|', qq(/bin/find $INCOMING -type f -print));
  while (<$fd>) {
    chomp;
    handle_inbound($_) if fileage($_) > 20;
  }
  close($fd);
}

# Below the actual main

setprogram(basename($0));
$0 = basename($0)." ".join(' ',@ARGV);

my %opts = ();
getopts('c:di:l:', \%opts);

BaseConfig::init($opts{'c'}) if defined $opts{'c'};

$Debug = 1 if defined $opts{'d'};
logchannel($opts{'l'}) if defined $opts{'l'};
my $Nthreads = (defined $opts{'i'} ? $opts{'i'} : $JOBINSTANCES);

chdir($INCOMING);
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

# start threads
threads->create('unpack_thread') for (1..$Nthreads);
threads->create('pending_thread');

my $inotify = new Linux::Inotify2
	|| errdie("$0: unable to create new inotify object: $!");
$inotify->blocking(0);
$inotify->watch($INCOMING, IN_MOVED_TO | IN_CLOSE_WRITE);

$DB = new GPSDB;	# GPSDB must be instantiated after thread creations
load_sites();

loginfo("$0 started. threads=$Nthreads, Debug=$Debug");

scan_incoming();

my $signal_received = '';
local $SIG{INT} = sub { $signal_received = 'interrupted' };
local $SIG{TERM} = sub { $signal_received = 'terminated' };
local $SIG{HUP} = sub { $signal_received = 'SIGHUP' };

my $ntimeouts = 0;
while (!$signal_received) {
  my $v = '';
  vec($v, $inotify->fileno, 1) = 1;
  select($v, undef, undef, 1);			# wait 1s for inotify has something
  if (vec($v, $inotify->fileno, 1)) {
    $ntimeouts = 0;
    my @events = $inotify->read;
    foreach my $e (@events) {
      handle_inbound($e->fullname);
    }
  } else {
    $ntimeouts++;
    if ($signal_received eq 'SIGHUP' || $ntimeouts % 600 == 0) {
      load_sites();
      scan_incoming();
    }
  }
  $signal_received = '' if $signal_received eq 'SIGHUP';
}

# shutdown threads
$PQ->enqueue({ command => 'EXIT' });
$PQ->end();
$UQ->end();
sleep 1 while threads->list(threads::running);		# wait for threads to terminate

loginfo("$0 stopped");
logclose();
exit(0);
