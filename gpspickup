#!/usr/bin/perl
#################
# Monitor for new inbound GPS data files from Permanent GNSS Stations.
# When a new file arrived, move it to $SAVEDIR and unpack it to $WORKDIR.
# Files are renamed to RINEXv3 standard naming during unpack.
#
# Soren Juul Moller, Nov 2019

use strict;
use warnings;
use Getopt::Std;
use Linux::Inotify2;
use BaseConfig;
use Utils;
use Logger;
use RinexSet;
use Job;
use GPSDB;

my %Inbound = ();
my %Pending = ();
my $DB;

chdir('/data/ftp');

#############################################################################################
# scan_incoming will add all plain files in /data/ftp to %Inbound
#
sub scan_incoming() {
  my $fd;
  open($fd, '-|', qq(/bin/find $INCOMING -type f -print));
  while (<$fd>) {
    chomp;
    next if fileage($_) < 2;
    my $fn = basename($_);
    next if exists $Inbound{$fn} || exists $Pending{$fn};
    $Inbound{$fn} = $_;
  }
  close($fd);
}

#############################################################################################
# Lookup site in gpssums. Returns true if current year-doy exists, false if not.
#
sub check_existing($$$$$) {
  my ($sql, $site, $year, $doy, $hour) = @_;

  my $aref = $DB->{DBH}->selectall_arrayref($sql, {Slice=>{}}, $site, $year, $doy, $hour);
  return (defined $aref && $$aref[0]->{cnt} == 1);
}


#############################################################################################
# Process all files in %Inbound
# Move complete filesets to workdir as is and create a job for processing the files
# Unknown sites and unknown filetypes for site are moved to Â£SAVEDIR/stale.
#
sub process() {
  my @flist = keys %Inbound;

  # Check for pending jobs
  #loginfo("check pending");
  foreach my $ident (keys %Pending) {
    my $job = $Pending{$ident};
    if (time() - $job->{'timestamp'} > 14) {
      # check nothing is being transferred right now
      my $rs = new RinexSet(rsfile => $job->{'rsfile'});
      my $prefix = $rs->getFilenamePrefix();
      my @inbound = glob("$INCOMING/${prefix}*");
      if (scalar(@inbound) == 0) {
        # no active inbound, then submit
        loginfo("submitting $ident");
        delete $job->{'timestamp'};
        $job->submitjob('ftp');
        delete $Pending{$ident};
      }
    }
  }
  return unless scalar(@flist) > 0;   # nothing to do

  # Get the complete list of defined sites from DB
  # We only use the short version of sitename here.
  my $sql = $DB->{'DBH'}->prepare(q{
	select	site, freq, obsint, navlist
	from	siteconfig
  });
  my $aref = $DB->{'DBH'}->selectall_arrayref($sql, { Slice => {} });
  die("No sites defined!?") if !defined $aref || scalar(@$aref) == 0;
  my %scs = map { uc(substr($_->{'site'},0,4)) => $_ } @$aref;

  # First each of the files found in /data/ftp, move them to it's workdir.
  # if its not already process
 
  $sql = $DB->{DBH}->prepare(q{
	select count(site) cnt
	from gpssums
	where site = ? and year = ? and doy = ? and hour = ?
  });

  foreach my $fn (@flist) {
    my $ifn = $Inbound{$fn};
    # assume sitename is the 4 first letters in filename
    my $site4 = uc(substr($fn, 0, 4));
    my $job = undef;

    # Make sure we know the site
    my $sc = $scs{$site4};
    if (!defined $sc) {
      sysmv($ifn, $SAVEDIR.'/stale', { log => 1 });
      logwarn("No such site: $site4");
      next;
    }
    my $site = $sc->{'site'};

    # Now that we know this is a known site, copy the file(s) to it's workdir and move to $SAVEDIR.
    # Derive the date & time from filename if possible.

    # Trinzic
    # ssssyyyymmddhhmiB.zip
    if ($fn =~ /^[A-Z0-9]{4}?(\d\d\d\d)(\d\d)(\d\d)(\d\d)\d\dB\.zip$/) {
      my ($year, $mm, $dd, $hh) = ($1, $2, $3, $4);
      my $doy = Day_of_Year($year, $mm, $dd);
      my $hour = hour2letter($hh);
      sysmv($ifn, "$SAVEDIR/$site", { log => 1, mkdir => 1 });
      $ifn = "$SAVEDIR/$site/$fn";
      if (check_existing($sql, $site, $year, $doy, $hour)) {
        print "$fn processed already. Forget it before reprocessing.\n";
        next;
      }
      $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
      $job->mkWorkdir();
      my $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour);
      $rs->unzip($ifn, $sc->{'obsint'});
      $rs->store();
      $job->{'rsfile'} = $rs->getRsFile;
    }

    # Leica
    # ssssdddh.yyo.zip
    elsif ($fn =~ /^[A-Z0-9]{4}(\d\d\d)([a-x])\.(\d\d)o\.zip$/) {
      my ($doy, $hour, $year) = ($1, $2, sy2year($3));
      sysmv($ifn, "$SAVEDIR/site", { log => 1, mkdir => 1 });
      $ifn = "$SAVEDIR/$site/$fn";
      if (check_existing($sql, $site, $year, $doy, $hour)) {
        print "$fn processed already. Forget it before reprocessing.\n";
        next;
      }
      $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
      $job->mkWorkdir();
      my $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour);
      $rs->unzip($ifn, $sc->{obsint});
      $rs->store();
      $job->{'rsfile'} = $rs->getRsFile;
    }

    # Septentrio (not zipped into one file)
    # Strategy is to submit job until the newest file is at least XXs old. Then its safe to assume all files have arrived
    # TA0200DNK_R_20190161900_01H_01S_MO.rnx
    # TA0200DNK_R_20190161800_01H_RN.rnx
    elsif ($fn =~ /^[A-Z0-9a-z]{9}_R_(\d{4})(\d{3})(\d\d)(\d\d)_.*_(MO|[A-Z]N)\.rnx/) {
      my ($year, $doy, $hh, $mi, $ftyp) = ($1, $2, $3, $4, $5);
      my $hour = hour2letter($hh);

      delete $Inbound{$fn};
      next unless -f $ifn;

      $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
      my $ident = $job->getIdent();
      my $workdir = $job->mkWorkdir();
      my $savedir = "$SAVEDIR/$site";
      my $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour);
      $job->{'rsfile'} = $rs->getRsFile();
      $rs->load() if -f $job->{'rsfile'};
      sysmv($ifn, $savedir, { log => 1, mkdir => 1 });
      $ifn = "$savedir/$fn";

      my $ufn = $fn; $ufn =~ s/\.gz$//;
      my $wfn = "$workdir/$ufn";
      if ($fn =~ /\.gz$/) {
        $wfn =~ s/\.gz$//;
        sysrun("gzip -dc $ifn >$wfn");
      } else {
        syscp($ifn, $wfn, { log => 1 });
      }
      $ftyp .= '.'.$sc->{'obsint'} if $ftyp eq 'MO';
      $rs->{$ftyp} = $ufn;
      $rs->store();
      $job->{'timestamp'} = time();
      $Pending{$ident} = $job;
      next;
    }

    # Unknown filename structure?!
    else {
      logerror("Unknown filetype for site $site: $ifn");
      sysmv($ifn, "$SAVEDIR/stale", { log => 1 });
    }

    # clear for inbound queue and submit a new job for processing
    delete $Inbound{$fn} if exists $Inbound{$fn};
    $job->submitjob('ftp') if defined $job;
  }
}

#############################################################################################
# Main program
#
my %opts = ();
getopts('dl:', \%opts);
my $log = defined $opts{'l'} ? $opts{'l'} : "/dev/null";

# Daemonize if required
my $PIDFILE = "$HOME/run/".basename($0).".pid";
daemonize($log) if defined $opts{'d'};
create_pid_file($PIDFILE);
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

my $inotify = new Linux::Inotify2
	|| errdie("$0: unable to create new inotify object: $!");
$inotify->watch($INCOMING, IN_MOVED_TO | IN_CLOSE_WRITE);

# Setup signal handling
my $sig_received = "";
sub signal_handler {
  $sig_received = shift;
  loginfo("$sig_received signal received. Exiting...");
}
local $SIG{HUP} = 'IGNORE';
local $SIG{INT} = \&signal_handler;
local $SIG{TERM} = \&signal_handler;

$DB = new GPSDB;

loginfo("$0 started");

$SIG{'ALRM'} = sub {
};

# Run loop until signal or pidfile is deleted
while (-f "$PIDFILE" && $sig_received eq "") {
  scan_incoming();

  if (scalar(keys %Inbound) == 0) {
    alarm 16;
    my @e = $inotify->read;
    alarm 0;

    foreach (@e) {
      my $fn = basename($_->fullname);
      $Inbound{$fn} = $_->fullname;
    }
  }
  process();
}

unlink($PIDFILE);
loginfo("$0 stopped");
exit(0);
