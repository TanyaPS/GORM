#!/usr/bin/perl
#############################################################################################
# Monitor for new inbound GPS data files from Permanent GNSS Stations.
# When a new file arrived, move it to $SAVEDIR and unpack it to $WORKDIR.
# Files are renamed to RINEXv3 standard naming during unpack.
#
# Soren Juul Moller, Nov 2019

use strict;
use warnings;
use Getopt::Std;
use Linux::Inotify2;
use BaseConfig;
use Utils;
use Logger;
use RinexSet;
use Job;
use GPSDB;

my $DB;
my %SCS;			# All sites defined
my %Pending;			# Postponed jobs to be submitted
my $Debug = 0;
my $PollInterval = 16;		# Timeout for new files


#############################################################################################
# Load all sites from locations table into %SCS
#
sub load_sites() {
  # Get the complete list of defined sites from DB
  # We only use the short version of sitename here.
  my $sql = $DB->{'DBH'}->prepare(q{
	select	site, freq, obsint
	from	locations
  });
  my $aref = $DB->{'DBH'}->selectall_arrayref($sql, { Slice => {} });
  die("No sites defined!?") if !defined $aref || scalar(@$aref) == 0;
  %SCS = map { uc(substr($_->{'site'},0,4)) => $_ } @$aref;
}


#############################################################################################
# Lookup site in gpssums. Returns true if current year-doy exists, false if not.
#
sub check_existing($$$$) {
  my ($site, $year, $doy, $hour) = @_;

  my $href = $DB->{'DBH'}->selectrow_hashref(q{
	select count(site) cnt
	from gpssums
	where site = ? and year = ? and doy = ? and hour = ?
  }, undef, $site, $year, $doy, $hour);
  return (defined $href && $href->{'cnt'});
}


#############################################################################################
# Process all files in %Inbound
# Move complete filesets to workdir as is and create a job for processing the files
# Unknown sites and unknown filetypes for site are moved to Â£SAVEDIR/stale.
#
sub process($$) {
  my ($ifn, $fn) = @_;

  # Make sure we know the site
  my $site4 = substr($fn, 0, 4);
  my $sc = $SCS{$site4};
  if (!defined $sc) {
    sysmv($ifn, $SAVEDIR.'/stale', { log => $Debug });
    logwarn("No such site: $site4");
    next;
  }
  my $site = $sc->{'site'};

  # Now that we know this is a known site, copy the file(s) to it's workdir and move to $SAVEDIR.
  # Derive the date & time from filename if possible.

  # Trinzic
  # ssssyyyymmddhhmiB.zip
  if ($fn =~ /^[A-Z0-9]{4}(\d\d\d\d)(\d\d)(\d\d)(\d\d)\d\dB\.zip$/) {
    my ($year, $mm, $dd, $hh) = ($1, $2, $3, $4);
    my $doy = Day_of_Year($year, $mm, $dd);
    my $hour = hour2letter($hh);
    sysmv($ifn, "$SAVEDIR/$site", { mkdir => 1, log => $Debug });
    $ifn = "$SAVEDIR/$site/$fn";
    if (check_existing($site, $year, $doy, $hour)) {
      logerror("$fn processed already. Forget it before reprocessing");
      return;
    }
    my $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
    my $workdir = $job->mkWorkdir();
    my $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint}, zipfile => $ifn);
    loginfo("Unzipping $fn to ".$rs->getWorkdir);
    $rs->unzip($ifn, $sc->{'obsint'});
    $rs->store();
    $job->{'rsfile'} = $rs->getRsFile;
    $job->submitjob('ftp');
  }

  # Leica
  # ssssdddh.yyo.zip
  elsif ($fn =~ /^[A-Z0-9]{4}(\d\d\d)([a-x])\.(\d\d)o\.zip$/) {
    my ($doy, $hour, $year) = ($1, $2, sy2year($3));
    sysmv($ifn, "$SAVEDIR/$site", { mkdir => 1, log => $Debug });
    $ifn = "$SAVEDIR/$site/$fn";
    if (check_existing($site, $year, $doy, $hour)) {
      logerror("$fn processed already. Forget it before reprocessing");
      return;
    }
    my $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
    my $workdir = $job->mkWorkdir();
    my $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint}, zipfile => $ifn);
    loginfo("Unzipping $fn to ".$rs->getWorkdir);
    $rs->unzip($ifn, $sc->{obsint});
    $rs->store();
    $job->{'rsfile'} = $rs->getRsFile;
    $job->submitjob('ftp');
  }

  # Septentrio raw format
  # ssssdddh.yy_
  elsif ($fn =~ /^[A-Z0-9]{4}([0-9]{3})([a-z])\.([0-9]{2})_/i) {
    my ($doy, $hour, $year) = ($1, lc($2), sy2year($3));
    sysmv($ifn, "$SAVEDIR/$site", { mkdir => 1, log => $Debug });
    $ifn = "$SAVEDIR/$site/$fn";
    my $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
    my $workdir = $job->mkWorkdir();
    my $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint}, rawfile => $ifn);
    loginfo("Unpack Septentrio raw file $fn into $workdir");
    chdir($workdir);
    my $countrycode = substr($site, 6, 3);
    sysrun("$SBF2RIN -f $ifn -l -R3 -nONGELHI -O $countrycode >/dev/null");
    chdir($INCOMING);
    $rs->checkfiles();
    $rs->store();
    $job->{'rsfile'} = $rs->getRsFile;
    $job->submitjob('ftp');
  }

  # Septentrio (not zipped into one file)
  # Strategy is to submit job until the newest file is at least XXs old. Then its safe to assume all files have arrived
  # TA0200DNK_R_20190161900_01H_01S_MO.rnx
  # TA0200DNK_R_20190161800_01H_RN.rnx
  elsif ($fn =~ /^[A-Z0-9a-z]{9}_R_(\d{4})(\d{3})(\d\d)(\d\d)_.*_(MO|[A-Z]N)\.rnx/) {
    my ($year, $doy, $hh, $mi, $ftyp) = ($1, $2, $3, $4, $5);
    my $hour = hour2letter($hh);
    my $job = new Job(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
    my $ident = $job->getIdent();

    my $savedir = "$SAVEDIR/$site";
    sysmv($ifn, $savedir, { mkdir => 1, log => $Debug });
    $ifn = "$savedir/$fn";

    my $workdir = $job->mkWorkdir();
    my $rs = new RinexSet(site => $site, year => $year, doy => $doy, hour => $hour, interval => $sc->{obsint});
    $job->{'rsfile'} = $rs->getRsFile();
    $rs->load() if -f $job->{'rsfile'};

    my $ufn = $fn; $ufn =~ s/\.gz$//;
    my $wfn = "$workdir/$ufn";
    if ($fn =~ /\.gz$/) {
      $wfn =~ s/\.gz$//;
      loginfo("Gunzip $fn to $workdir");
      sysrun("gzip -dc $ifn >$wfn", { log => $Debug });
    } else {
      loginfo("Copy $fn to $workdir");
      syscp($ifn, $wfn, { log => $Debug });
    }
    $ftyp .= '.'.$sc->{'obsint'} if $ftyp eq 'MO';
    $rs->{$ftyp} = $ufn;
    $rs->store();

    # Update timestamp for each file added to this job
    $job->{'timestamp'} = time();
    # Register pending job only if we got the observation file (see submit_pending)
    if ($fn =~ /_MO\.rnx/) {
      $Pending{$fn} = $job;
    }
  }

  # Unknown filename structure?!
  else {
    logerror("Unknown filetype for site $site: $ifn");
    sysmv($ifn, "$SAVEDIR/stale", { log => $Debug });
  }
}


#############################################################################################
# scan_incoming will add all plain files in $INCOMING to %Inbound
#
sub scan_incoming() {
  my $fd;
  open($fd, '-|', qq(/bin/find $INCOMING -type f -print));
  while (<$fd>) {
    chomp;
    process($_, basename($_)) if fileage($_) > 15;
  }
  close($fd);
}


#############################################################################################
# Submit pending jobs if no files with same prefix is present in $INCOMING
# A job is pending if this is a multi-file upload and the obs file is received. It will be
# submitted if no new files have arrived the last 15s.
#
sub submit_pending() {
  my @pending = keys %Pending;
  foreach my $fn (@pending) {
    my $job = $Pending{$fn};
    if (time() - $job->{'timestamp'} > 14) {
      # check nothing is being transferred right now
      my $rs = new RinexSet(rsfile => $job->{'rsfile'});
      my $prefix = $rs->getFilenamePrefix();
      next if scalar(grep(/^$prefix/, dirlist($INCOMING))) > 0;
      # no active inbound found, then submit
      loginfo("Submitting ".$job->getIdent());
      delete $job->{'timestamp'};
      $job->submitjob('ftp');
      delete $Pending{$fn};
    }
  }
  my $left = scalar(keys %Pending);
  loginfo("Pending left: $left") if $left > 0;
}


#############################################################################################
# Called from Linux::Inotify2 for each file event
#
sub inotify_callback() {
  my $event = shift;
  alarm 0;		# disable timer while processing
  process($event->fullname, $event->name);
  alarm $PollInterval;	# rearm timer
}


#############################################################################################
# Main program
#
setprogram(basename($0));
$0 = basename($0)." ".join(' ',@ARGV);

my %opts = ();
getopts('dl:', \%opts);

$Debug = 1 if defined $opts{'d'};
logchannel($opts{'l'}) if defined $opts{'l'};

chdir($INCOMING);
select(STDERR); $| = 1;
select(STDOUT); $| = 1;

my $inotify = new Linux::Inotify2
	|| errdie("$0: unable to create new inotify object: $!");
$inotify->watch($INCOMING, IN_MOVED_TO | IN_CLOSE_WRITE, \&inotify_callback);

$DB = new GPSDB;
load_sites();

loginfo("$0 started. Debug=$Debug");

scan_incoming();

while (1) {
  eval {
    local $SIG{ALRM} = sub { die("gpspickupalarm"); };
    local $SIG{INT} = sub { die("interrupted"); };
    local $SIG{TERM} = sub { die("terminated"); };
    local $SIG{HUP} = 'IGNORE';
    alarm $PollInterval;
    $inotify->poll;	# wait for new file in $INCOMING
    alarm 0;
  };
  if ($@) {
    my $msg = $@;
    last unless $msg =~ /^gpspickupalarm/;	# poll timeout?
    scan_incoming();
    submit_pending();
  }
}

loginfo("$0 stopped");
exit(0);
